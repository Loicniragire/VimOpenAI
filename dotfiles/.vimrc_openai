
" OPENAI
" Directory structure
" - OPENAI_WORKING_DIR
"   - OPENAI_PROJECT_HOME_DIR
"       - requests
"       - responses
"       - output
"       - source
"
" Within a working directory, there can be multiple projects.
" To set the working directory to default, use the command :OpenAISetWorkingProject <project_path>
"
" Notes:
" A thread is created by namespace. When creating a thread message, user specifies the classname and the request message.
" Using the classname, the assistant determines which namespace the class belong to and creates a thread for that namespace if it doesn't exist.
" When user requests the assistant to execute the thread, all the messages in the thread are sent to the assistant for processing. The
" assistant will process the messages in the order they were received. The assistant will also keep track of the state of the thread.
" The assistant will return the response for each message in the thread. The assistant will also return the state of the thread.
"
" Usage:
" 0. Updated g:OPENAI_PROJECT_HOME_DIR as needed. Using the command :OpenAISetHomeDir <project_path>. Use :OpenAIGetHomeDir to get the current value.
" 1. Setup working project. This is the cs project containing the files to word with. Command: OpenAISetupProject <project_path>
" 2. Navigate the the requests directory and create a message file. There should be a sample request file. Note that classname is case sensitive.
" 3. Submit created message. Command: OpenAICreateMessage <message_file_name>. This should return the created message with a thread id.
" 4. Execute the thread. Command: OpenAIExecuteThread <thread_id>. This should return the response for each message in the thread. 
" The assistant has access to all previously created messages - as found in the thread responses.
"
" When a new message is created, the same thread will be used only if the classes are in the same namespace. Otherwise a new thread is
" created for the new namespace.
"
" BASIC USAGE
" 1. Navigate to the project directory and setup the project. Command: OpenAISetupProject <project_path>
" 2. Create a thread message. Command: OpenAICreateMessage <message_file_name>. Navigate to Output Directory to view
" message.
" 3. To retrieve multiple messages from a thread, use the command: OpenAIListThreadMessages <thread_id> <limit>

let s:logfile = ''
set encoding=utf-8
let g:OPENAI_WORKING_DIR = '~/Documents/AI_ProjectAssistant/'

let g:OPENAI_LIST_VECTOR_STORES_CMD = 'curl https://api.openai.com/v1/vector_stores -H "Content-Type: application/json" -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2"'

let g:OPENAI_VECTOR_STORE_CMD = 'curl -X POST https://api.openai.com/v1/vector_stores -H "Content-Type: application/json" -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" -d '
let g:OPENAI_DELETE_VECTOR_STORE_CMD = 'curl -sS -X DELETE https://api.openai.com/v1/vector_stores/{vector_store_id} -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2"'

let g:OPENAI_VECTOR_STORE_FILE_CMD = 'curl -sS -X POST https://api.openai.com/v1/vector_stores/{vector_store_id}/file_batches -H "Content-Type: application/json" -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" -d '

let g:OPENAI_ASSIGN_VECTOR_STORE_TO_ASSISTANT_CMD = 'curl -sS -X POST https://api.openai.com/v1/assistants/{assistant_id} -H "Content-Type: application/json" -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" -d '

let g:OPENAI_COMPLETION_CMD = 'curl -sS -X POST https://api.openai.com/v1/chat/completions -H "Content-Type: application/json" -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -d @'

let g:OPENAI_ASSISTANTS_CMD = 'curl -X POST https://api.openai.com/v1/assistants -H "Content-Type: application/json" -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" '

let g:OPENAI_FILES_CMD = 'curl -sS -X POST https://api.openai.com/v1/files -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -F "purpose=assistants" -F "file=@"'

let g:OPENAI_ASSIGN_FILE_TO_ASSISTANT_CMD = 'curl -sS -X POST https://api.openai.com/v1/assistants/{assistant_id}/files -H "Content-Type: application/json" -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" -d '
let g:OPENAI_DELETE_FILE_CMD = 'curl -sS -X DELETE https://api.openai.com/v1/files/{file_id} -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" '
let g:OPENAI_RETRIEVE_FILE_CMD = 'curl https://api.openai.com/v1/files/{file_id}/content -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" '
let g:OPENAI_LIST_FILES_CMD = 'curl https://api.openai.com/v1/files -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" '
let g:OPENAI_LIST_ASSISTANTS_CMD = 'curl https://api.openai.com/v1/assistants -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" '
let g:OPENAI_DELETE_ASSISTANT_CMD = 'curl -sS -X DELETE  https://api.openai.com/v1/assistants/{assistant_id} -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" '
let g:OPENAI_ASSISTANT_THREAD_CMD = 'curl https://api.openai.com/v1/threads -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" -d ""  '
let g:OPENAI_DELETE_ASSISTANT_THREAD_CMD = 'curl -X DELETE  https://api.openai.com/v1/threads/{thread_id} -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" '
let g:OPENAI_ASSISTANT_THREAD_MESSAGE_CMD = 'curl https://api.openai.com/v1/threads/{thread_id}/messages -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" -d '
let g:OPENAI_ASSISTANT_RETRIEVE_MESSAGE_CMD = 'curl https://api.openai.com/v1/threads/{thread_id}/messages/{message_id} -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2"'

let g:OPENAI_ASSISTANT_LIST_THREAD_MESSAGE_CMD = 'curl "https://api.openai.com/v1/threads/{thread_id}/messages?limit={msg_limit}" -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" '
let g:OPENAI_ASSISTANT_THREAD_RUN_CMD = 'curl https://api.openai.com/v1/threads/{thread_id}/runs -H "Content-Type: application/json" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" -d '
let g:OPENAI_ASSISTANT_RETRIEVE_THREAD_RUN_CMD = 'curl https://api.openai.com/v1/threads/{thread_id}/runs/{run_id} -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -H "OpenAI-Beta:assistants=v2" '
let g:OPENAI_ASSISTANT_MODEL = 'gpt-4o'
let g:OPENAI_ASSISTANT_TEMPERATURE = 0.5


let g:OPENAI_CS_PROJECT_ASSISTANT_INSTUCTIONS = 'The assistant is tasked to work on various .NetCore projects, ' .
    \ 'each involving different files and functionalities. The projects are primarily developed in CSharp. ' .
	\ 'All the project files have been uploaded as text (.txt) files. Each file represents a single namespace from the project' .
	\ 'and the filename corresponds to the namespace name. Within each file, all classes, interfaces, and other types that belong to that namespace ' .
	\ 'are included.' .
    \ 'Tasks: ' .
    \ '1. Code Analysis: Perform a comprehensive analysis on the provided .NetCore project files, ' .
    \ 'focusing on performance, security, and adherence to best practices. Identify areas for improvement and suggest optimizations. ' .
    \ '2. Feature Implementation and Enhancement: Based on the project requirements, implement new features or ' .
    \ 'enhance existing functionalities. Ensure that implementations are efficient, maintainable, and align with the project''s overall architecture. ' .
    \ '3. Code Generation: Generate CSharp code snippets or entire modules as required by the specific project. ' .
    \ 'The code should be compatible with the .NetCore version in use and follow established coding conventions. ' .
	\ 'Requirements will be provided in the format of GIVEN, WHEN, THEN statements. ' .
    \ '4. Testing and Documentation: Develop testing strategies, including unit and integration tests, ' .
    \ 'to ensure the robustness of new or modified code. Produce concise documentation for the implemented code, ' .
    \ 'outlining its purpose, usage, and any special considerations. ' .
	\ '5. Format all generated code or content text to make the readible and understandable. ' .
    \ '6. File Management: Manage and organize project files efficiently, ensuring that the project structure is maintained and easily navigable. ' .
    \ 'Expected Deliverables: For each project, deliver a report on code analysis, implemented features or enhancements with corresponding CSharp code, ' .
    \ 'testing strategies, and documentation. Projects should be left in a clean, well-documented state. ' .
    \ 'General Considerations: Adapt to the specific requirements of each project, including but not limited to different .NetCore versions, ' .
    \ 'third-party libraries, and database integrations. Ensure compatibility and seamless integration with existing project components. ' .
    \ 'Deadline: As per individual project timelines.' .
    \ 'For any code generated by the assistant, the assistant should return a file_id that can be used to download generated code. ' 

function! SetToDefaultWorkingDir()
	let l:defaultHome = fnamemodify(g:OPENAI_WORKING_DIR, ':p')
    let l:projectHomeDirectory = l:defaultHome . 'default/'
	let l:requestsDir = l:projectHomeDirectory . 'requests'
	let l:responsesDir = l:projectHomeDirectory . 'responses'
	let l:outputDir = l:projectHomeDirectory . 'output'
	let l:sourceDir = l:projectHomeDirectory . 'source'


	call ClearPersistentVariables()
	call SetPersistentVariable('OPENAI_PROJECT_HOME_DIR', l:defaultHome)
	call SetPersistentVariable('OPENAI_REQUESTS_DIR', l:requestsDir)
	call SetPersistentVariable('OPENAI_RESPONSES_DIR', l:responsesDir)
	call SetPersistentVariable('OPENAI_OUTPUT_DIR', l:outputDir)
	call SetPersistentVariable('OPENAI_SOURCE_DIR', l:sourceDir)

    " Create the directories if they don't exist
    call mkdir(l:projectHomeDirectory, 'p')
    call mkdir(l:requestsDir, 'p')
    call mkdir(l:responsesDir, 'p')
    call mkdir(l:outputDir, 'p')
    call mkdir(l:sourceDir, 'p')

    "echo directory paths
    echo 'OPENAI_PROJECT_HOME_DIR: ' . g:OPENAI_PROJECT_HOME_DIR
    echo 'OPENAI_REQUESTS_DIR: ' . g:OPENAI_REQUESTS_DIR
    echo 'OPENAI_RESPONSES_DIR: ' . g:OPENAI_RESPONSES_DIR
    echo 'OPENAI_OUTPUT_DIR: ' . g:OPENAI_OUTPUT_DIR
    echo 'OPENAI_SOURCE_DIR: ' . g:OPENAI_SOURCE_DIR
endfunction

" command to reset the working directory to default
" It creates a default directory structure under the OPENAI_WORKING_DIR
" and sets the global variables to point to the newly created directories.
command! -nargs=0 OpenAISetToDefault call SetToDefaultWorkingDir()

" Function to attach the given fileId to the specified assistantId
" Parameters:
" Payload model: { "file_id": ""}
function! AssignOpenAIFileToAssistant(assistantId, requestPayload, outputfile)
	let l:cmd = g:OPENAI_ASSIGN_FILE_TO_ASSISTANT_CMD
	let l:response = substitute(l:cmd,'{assistant_id}',a:assistantId,'')
	let l:curl_cmd = l:response. '@' . a:requestPayload . ' -o ' . a:outputfile
	execute '!' . l:curl_cmd
	execute 'edit ' . a:outputfile
endfunction


" Define a function to execute the curl command
function! SendToOpenAI(requestPayload, outputfile, endpoint)
	" Construct the curl command
	let l:curl_cmd = ''
	if a:endpoint == 'Completions'
		let l:curl_cmd = g:OPENAI_COMPLETION_CMD. a:requestPayload . ' -o ' . a:outputfile
	elseif a:endpoint == 'Assistants'
		let l:curl_cmd = g:OPENAI_ASSISTANTS_CMD. ' -d @' . a:requestPayload . ' -o ' . a:outputfile
	elseif a:endpoint == 'AssistantFiles'
		let l:curl_cmd = g:OPENAI_FILES_CMD. a:requestPayload . ' -o ' . a:outputfile
	endif
	" Execute the curl command
	" execute '!' . l:curl_cmd
	" execute 'edit ' . a:outputfile
	"echo 'curl_cmd: ' . l:curl_cmd
endfunction

function! GetOpenAIUploadedFiles(outputfile)
	let l:curl_cmd = g:OPENAI_LIST_FILES_CMD . ' -o ' . a:outputfile
	execute '!' . l:curl_cmd
	execute 'edit ' . a:outputfile
endfunction

function! GetOpenAIAssistants(outputfile)
	let l:curl_cmd = g:OPENAI_LIST_ASSISTANTS_CMD . ' -o ' . a:outputfile
	execute '!' . l:curl_cmd
	" open outputfile in a new buffer
	execute 'edit ' . a:outputfile
	
endfunction

" Deletes an uploaded Assistant file
" Parameters:
" fileId: Id of the file to delete
" Returns:
" None
function! DeleteOpenAIAssistantFile(fileId)
	let l:cmd = g:OPENAI_DELETE_FILE_CMD
	let l:curl_cmd = substitute(l:cmd,'{file_id}',a:fileId,'')
	execute 'silent !' . l:curl_cmd
endfunction

function! DeleteOpenAIAssistant(assistantId)
	let l:cmd = g:OPENAI_DELETE_ASSISTANT_CMD
	let l:curl_cmd = substitute(l:cmd,'{assistant_id}',a:assistantId,'')
	execute '!' . l:curl_cmd
	call ClearPersistentVariables()
endfunction

function! CreateOpenAIAssistantThread()
	let l:outputfile = g:OPENAI_OUTPUT_DIR . '/threads_output_tmp.json'
	let l:cmd = g:OPENAI_ASSISTANT_THREAD_CMD . ' -o ' . l:outputfile

    "echo 'cmd: ' . l:cmd
	execute 'silent !' . l:cmd
	" Read the content of the output file as a string
	let output = join(readfile(l:outputfile), "\n")
	return output
endfunction

" Create a thread pool of assistants
" Parameters:
" count: Number of threads to create
"command! -nargs=1 OpenAICreateAssistantThreadPool call CreateOpenAIAssistantThreads(<f-args>)

function! DeleteOpenAIAssistantThread(threadId)
	let l:cmd = g:OPENAI_ASSISTANT_THREAD_CMD
	let l:curl_cmd = substitute(l:cmd,'{thread_id}',a:threadId,'')
	execute '!' . l:cmd
endfunction

function! MessageJsonPayload(message)
	let l:messageRole = 'user'
	" let l:payload = "{" .  "\"role\": "  . '"'. l:messageRole . '",' .  "\"content\": " . '"' . a:message . '",' .  "\"file_ids\": " . l:file_ids .  "}"
     "return json_encode(l:payload)
	 let l:payload = {
				 \ 'role': l:messageRole,
				 \ 'content': a:message
				 \}
     return json_encode(l:payload)
endfunction

function! ThreadMessageJsonPayload(threadId, message)
	let l:payload = {
				\ 'threadid': a:threadId,
				\ 'message': a:message
				\}
	return json_encode(l:payload)
endfunction

function! CreateThreadMessage(messageRequest, outputfile)
	let jsonObj = json_decode(a:messageRequest)

	" convert json object to dictionary
	let l:jsonObjDict = {}
	for [key, value] in items(jsonObj)
		let l:jsonObjDict[key] = value
	endfor

	if has_key(jsonObjDict, "threadid") && has_key(jsonObjDict, "message")
		let l:threadId = jsonObjDict["threadid"]
		let l:messageContent = jsonObjDict["message"]
	else
		echoerr "Invalid JSON structure: 'threadid' or 'message' key not found"
		return
	endif

	let l:requestPayload = MessageJsonPayload(l:messageContent)
    let l:jsonEncodedPayload = json_encode(l:requestPayload)

	"echo 'requestPayload: ' . l:escapedPayload
	let l:cmd = g:OPENAI_ASSISTANT_THREAD_MESSAGE_CMD
	let l:response = substitute(l:cmd,'{thread_id}',l:threadId,'')

    let l:generatedOutputFile = g:OPENAI_REQUESTS_DIR . '/' . l:threadId . '_' . a:outputfile

	let l:curl_cmd = l:response. l:jsonEncodedPayload . ' -o ' . l:generatedOutputFile
    "echo 'curl_cmd - CreateThreadMessage: ' . l:curl_cmd
	execute 'silent !' . l:curl_cmd
    return l:generatedOutputFile
endfunction

function! OpenAIAssistantThreadListMessages(threadId, limit, outputfile)
	let l:cmd = g:OPENAI_ASSISTANT_LIST_THREAD_MESSAGE_CMD
	let l:response = substitute(l:cmd,'{thread_id}',a:threadId,'')
	let l:response = substitute(l:response,'{msg_limit}', a:limit, '')

	if executable('jq')
		let l:curl_cmd = l:response . ' | jq .' . ' > ' . a:outputfile
	else
		let l:curl_cmd = l:response . ' -o ' . a:outputfile
	endif

	execute '!' . l:curl_cmd
	execute 'edit ' . a:outputfile
endfunction



function! s:CheckJsonTool()
    " Run a test command with Python's json.tool and capture the output
    let l:testCmd = 'python -c "import json; print(json.dumps({}))" | python -m json.tool'
    let l:result = system(l:testCmd)
    " Check if the command executed successfully
    return v:shell_error == 0
endfunction

function! CreateOpenAIAssistantThreadRun(threadId, requestPayload, outputfile)
	let l:cmd = g:OPENAI_ASSISTANT_THREAD_RUN_CMD
	let l:response = substitute(l:cmd,'{thread_id}',a:threadId,'')
	let l:curl_cmd = l:response. "@" . a:requestPayload . ' -o ' . a:outputfile
	execute '!' . l:curl_cmd
	execute 'edit ' . a:outputfile
endfunction

function! RetrieveOpenAIAssistantThreadRun(threadId, runId, outputfile)
	let l:cmd = g:OPENAI_ASSISTANT_RETRIEVE_THREAD_RUN_CMD
	let l:response = substitute(l:cmd,'{thread_id}',a:threadId,'')
	let l:response = substitute(l:response,'{run_id}',a:runId,'')
	let l:curl_cmd = l:response . ' -o ' . a:outputfile
	execute '!' . l:curl_cmd
endfunction

" Define a Vim command that calls the function
"command! -nargs=+ OpenAICompletions call SendToOpenAI(<f-args>, 'Completions')
"command! -nargs=+ OpenAIAssistants call SendToOpenAI(<f-args>, 'Assistants')
"command! -nargs=+ OpenAIAAssistantFiles call SendToOpenAI(<f-args>, 'AssistantFiles')

"command! -nargs=+ OpenAIAssignFileToAssistant call AssignOpenAIFileToAssistant(<f-args>, g:OPENAI_OUTPUT_DIR . '/openai_assign_file_to_assistant_output.json')
command! -nargs=0 OpenAIListUploadedFiles call GetOpenAIUploadedFiles(g:OPENAI_OUTPUT_DIR . '/openai_list_files_output.json')
command! -nargs=0 OpenAIListAssistants call GetOpenAIAssistants(g:OPENAI_OUTPUT_DIR . '/openai_list_assistants_output.json')
command! -nargs=1 OpenAIDeleteAssistant call DeleteOpenAIAssistant(<f-args>)


" Command to list thread messages. The command takes the threadId and limit as arguments
" arg1: threadId
" arg2: limit
command! -nargs=+ OpenAIAssistantListThreadMessages call OpenAIAssistantThreadListMessages(<f-args>, g:OPENAI_OUTPUT_DIR . '/openai_assistant_thread_list_messages_output.json');

" Define a function to list files with specified extensions in a directory
" Parameters:
" directoryPath: Path to the directory containing the files to list
" extMap: Dictionary mapping original extensions to new extensions
" outputDir: Path to the directory where the files will be copied. It will create the directory if it doesn't exist.
" Returns:
" None
"
"
" Sample call:
" :call ListFilesWithExtensions('C:\Users\user\Documents\test', {'cs': 'txt'}, 'C:\Users\user\Documents\test\output')
" Output: Copied with UTF-8 encoding: C:\Users\user\Documents\test\test.cs -> C:\Users\user\Documents\test\output\test.txt
" 	   Copied with UTF-8 encoding: C:\Users\user\Documents\test\test2.cs -> C:\Users\user\Documents\test\output\test2.txt
" 	   Copied with UTF-8 encoding: C:\Users\user\Documents\test\test3.cs -> C:\Users\user\Documents\test\output\test3.txt

function! ListFilesWithExtensions(directoryPath, extMap, outputDir, ignoreFiles)
    " Create the output directory if it doesn't exist
    if !isdirectory(a:outputDir)
        call mkdir(a:outputDir, 'p')
    endif

    " Define a helper function for recursive listing and copying
    function! s:ListDirRecursively(path, extMap, outputDir, ignoreFiles)
        " List all items in the current directory
        for item in split(glob(a:path . '/*'), '\n')
            " Skip if item is an empty string (happens when glob finds nothing)
            if empty(item)
                continue
            endif

            " Check if the item is in the ignore list
            let itemName = fnamemodify(item, ':t')
            if itemName =~ '\V\<' . join(a:ignoreFiles, '\>\|\<') . '\>'
                call LogMessage('Ignoring: ' . itemName)
                continue
            endif

            " Check if item is a directory
            if isdirectory(item)
                " Recursively list and copy files in this directory
                call s:ListDirRecursively(item, a:extMap, a:outputDir, a:ignoreFiles)
            elseif filereadable(item)
                " Iterate through each extension in the map
                for origExt in keys(a:extMap)
                    " Check if file has the original extension
                    if item =~ '\.' . origExt . '$'
                        " Determine the new extension
                        let newExt = get(a:extMap, origExt, origExt)
                        if newExt == ''
                            let newExt = origExt
                        endif
                        let newFileName = fnamemodify(item, ':t:r') . '.' . newExt
                        let newFilePath = a:outputDir . '/' . newFileName
                        " Copy the file using the shell
                        if has('win32')
                            execute 'silent !copy ' . shellescape(item) . ' ' . shellescape(newFilePath)
                        else
                            execute 'silent !cp ' . shellescape(item) . ' ' . shellescape(newFilePath)
                        endif

                        " Output the operation
                        call LogMessage('Copied with UTF-8 encoding: ' . item . ' -> ' . newFilePath)
                        break
                    endif
                endfor
            endif
        endfor
    endfunction

    " Start the recursive listing and copying with the ignore list
    call s:ListDirRecursively(a:directoryPath, a:extMap, a:outputDir, a:ignoreFiles)
endfunction

function! GetUploadedFileIds(outputfile, maxFiles)
    " Read the entire file and decode the top-level JSON array
    let json_strings = json_decode(join(readfile(a:outputfile), "\n"))
    let l:uploadedFileIds = []
    let l:filename = ''

    " Check if there are more than 'maxFiles' items, if so set a specific filename to filter on
	" i.e we will only upload the merged file since to limit the number of files uploaded to vector store
	" Check the max capacity of the vector store to set this limit correctly.
    if len(json_strings) > a:maxFiles
        let l:filename = 'merged.txt'
    endif

    " Iterate over each JSON string in the array
    for json_str in json_strings
        " Decode each JSON string into a dictionary
        let item = json_decode(json_str)

        " If a specific filename is set, match it; otherwise, add all file IDs
        if !empty(l:filename) && has_key(item, 'filename') && item['filename'] == l:filename
            call add(l:uploadedFileIds, item['id'])
        elseif empty(l:filename)
            call add(l:uploadedFileIds, item['id'])
        endif
    endfor

    return l:uploadedFileIds
endfunction

" Define a Vim command that calls the function with a map of extensions
"command! -nargs=1 ExtractCsFiles call ListFilesWithExtensions(<f-args>, {'cs': 'txt'}, fnamemodify(<f-args>, ':t') .  '_project')


" arg1: directoryPath containing artifacts from ExtractCsFiles command
"command! -nargs=1 OpenAICreateCsProjectAssistant call CreateOpenAICsProjectAssistant(<f-args>,fnamemodify(<f-args>, ':t') . '_assistant')
" Function to create an OpenAI assistant for a project
" Parameters:
" directoryPath: Path to the directory containing the files to upload
" projectName: Name to assign to the assistant
" Returns:
" Assistant creation response
function! CreateOpenAICsProjectAssistant(directoryPath, projectName)

	let l:fileExtMapping = {'cs': '', 'config': 'txt', 'csproj': 'txt', 'sln': 'txt', 'sql': 'txt'}
	let l:ignoredFilesAndDirs = ['GlobalUsings.cs','bin','obj','packages','node_modules', 'cache','.vscode','.angular']

	call LogMessage("0. Starting....Extracting source code files from directory: " . a:directoryPath)
	call ListFilesWithExtensions(a:directoryPath, l:fileExtMapping, g:OPENAI_SOURCE_DIR, ignoredFilesAndDirs )

	call LogMessage("1. Starting....Merging files in directory: " . g:OPENAI_SOURCE_DIR)
    let l:mergedFile = g:OPENAI_SOURCE_DIR . '/merged.txt'
    call MergeFiles(g:OPENAI_SOURCE_DIR, l:mergedFile)

	call LogMessage("2. Starting....Grouping files by namespace")
	call GroupFilesByNamespace(g:OPENAI_SOURCE_DIR, l:mergedFile)
	let l:assistantName = fnamemodify(g:OPENAI_PROJECT_HOME_DIR, ':t') . '_assistant'

	call LogMessage("3. Starting....Created project assistant: " . l:assistantName)

	"get the full path of the directory
	let l:directoryPath = fnamemodify(a:directoryPath, ':p')
	call LogMessage('Creating assistant for project: ' . a:projectName . ' with files in directory: ' . l:directoryPath)
	"Generate an assistant for the project
	let l:assistantId = CreateProjectAssistant(a:projectName, 'A generic .NetCore project assistant', g:OPENAI_CS_PROJECT_ASSISTANT_INSTUCTIONS)

	"
	" Create a vector store and upload project files
	" Vector Store arguments the Assistant with knowledge from outside its model,
	" such as proprietary information or documents provided by the user.
	" Note that all these files have to be uploaded first.
	" Each Vector Store can hold up to 10,000 files.
	" The maximum file size is 512 MB
	" Vector Stores support most file types - see: 
	" https://platform.openai.com/docs/assistants/tools/file-search/supported-files
	"
	let l:vectorStoreName = a:projectName
	let l:vectoreStoreExpirationDays = 1
	let l:vectorStoreId = CreateVectorStore(l:vectorStoreName, l:vectoreStoreExpirationDays)
	call UploadFiles(g:OPENAI_SOURCE_DIR)
	let l:uploaded_file_ids_output = g:OPENAI_OUTPUT_DIR . '/openai_uploaded_file_ids_output.json'
	let l:uploadedFileIds = GetUploadedFileIds(l:uploaded_file_ids_output, 10000)

	let l:uploadedFileIdsReq = json_encode({"file_ids": l:uploadedFileIds}) 
	call LogMessage('Uploaded file ids: ' . l:uploadedFileIdsReq)

	let l:outputfile = g:OPENAI_OUTPUT_DIR . '/openai_upload_files_to_vector_store_output.json'
	let l:cmd = g:OPENAI_VECTOR_STORE_FILE_CMD
	let l:response = substitute(l:cmd,'{vector_store_id}',l:vectorStoreId,'')
	let l:curl_cmd = l:response . shellescape(l:uploadedFileIdsReq) . ' -o ' . l:outputfile
	call LogMessage('curl_cmd: ' . l:curl_cmd)

	" assign uploaded files to vector store
	execute 'silent !' . l:curl_cmd
	" Maximum number of attempts to check the 'completed' status
	let l:max_attempts = 12

	" Start polling the output file
	for i in range(l:max_attempts)
		" Wait for a bit before checking the status
		call timer_start(5000, {-> v:null})

		" Read and parse the JSON output
		let l:json_output = json_decode(join(readfile(l:outputfile), "\n"))

		" Check if the status is 'completed'
		if has_key(l:json_output, 'status') && l:json_output['status'] == 'completed'
			call LogMessage("Vector store creation completed successfully. Id: " . l:json_output['id'])
			break
		elseif has_key(l:json_output, 'status') && l:json_output['status'] == 'failed'
			echoerr "Error in creating vector store: " . l:json_output['error_message']
			break
		endif

		" Provide feedback on the status in the command line
		call LogMessage("Checking completion status... (attempt " . (i+1) . ")")
	endfor
	" redraw!

    let l:assistantOutput = g:OPENAI_OUTPUT_DIR . '/openai_create_project_assistant_output.json'
	let l:vectorStorePayload = GetVectorStoreToolResources(l:vectorStoreId, l:uploadedFileIds)
	call LogMessage('Vector store payload: ' . l:vectorStorePayload)


	let l:vectorStoreAssignCmd = g:OPENAI_ASSIGN_VECTOR_STORE_TO_ASSISTANT_CMD
	let l:vectorStoreAssignResponse = substitute(l:vectorStoreAssignCmd, '{assistant_id}', l:assistantId, '')
	let l:vectorStoreAssignCurlCmd = l:vectorStoreAssignResponse . shellescape(l:vectorStorePayload) . ' -o ' . l:assistantOutput

	execute '!' . l:vectorStoreAssignCurlCmd
	" let l:ids = json_encode(l:uploadedFileIds)
	call WriteJSONToFile(l:uploadedFileIds, g:OPENAI_OUTPUT_DIR . '/openai_uploaded_file_ids_output.json')
	return l:vectorStorePayload
endfunction


" Function to map the values of two arrays in a dictionary
" Parameters:
" input_dict: Dictionary containing the arrays
" search_key: Key for the array containing the keys
" search_value: Key for the array containing the values
" Returns:
" Dictionary with the keys and values mapped
" Sample call:
" :echo MapValues({'id': ['1', '2'], 'filename': ['abc', 'rf']}, 'filename', 'id')
" Output: {'abc': '1', 'rf': '2'}
function! MapValues(input_dict, search_key, search_value)
    " Create a dictionary to store the results
    let resultDict = {}

    " Ensure that both search_key and search_value exist in input_dict
    if has_key(a:input_dict, a:search_key) && has_key(a:input_dict, a:search_value)
        " Get the arrays associated with the search_key and search_value
        let searchKeyArray = a:input_dict[a:search_key]
        let searchValueArray = a:input_dict[a:search_value]

        " Ensure the arrays are of the same length
        if len(searchKeyArray) == len(searchValueArray)
            " Iterate over the arrays and map the values
            for i in range(len(searchKeyArray))
                let key = searchKeyArray[i]
                let value = searchValueArray[i]
                let resultDict[key] = value
            endfor
        else
            call LogMessage("Error: Arrays for search_key and search_value are of different lengths.")
        endif
    else
        call LogMessage("Error: One or both keys not found in the input dictionary.")
    endif

    return resultDict
endfunction



function! WriteJSONToFile(jsonArray, filename)
    " Check if jsonArray is indeed a list
    if type(a:jsonArray) != type([])
        echoerr 'Invalid input: jsonArray should be a list'
        return
    endif

    " Validate that each item in jsonArray is a string
    for item in a:jsonArray
        if type(item) != type('')
            echoerr 'Invalid input: each item in jsonArray should be a string'
            return
        endif
    endfor

    " Use json_encode to handle all JSON formatting
    let l:jsonString = json_encode(a:jsonArray)

    " Write the JSON string to the file
    call writefile(split(l:jsonString, '\n'), a:filename, 'b')
endfunction

" Function to delete all files uploaded to OpenAI Assistant.
" Parameters:
" None
" Returns:
" None
function! DeleteAllAssistantFiles()
	let l:outputfile = g:OPENAI_OUTPUT_DIR . '/openai_list_files_output.json'
	let l:cmd = g:OPENAI_LIST_FILES_CMD . ' -o ' . l:outputfile
	execute '!' . l:cmd

	" if the output file doesn't exist, or is empty, return
	if !filereadable(l:outputfile) || getfsize(l:outputfile) == 0
		call LogMessage('No OPENAI files found')
		return
	endif

	function! s:DeleteFilesById(jsonStr)
		let l:cmd = g:OPENAI_DELETE_FILE_CMD
		" Decode the JSON string
		let jsonObj = json_decode(a:jsonStr)
		" Check if 'data' key exists and is a List
		if has_key(jsonObj, 'data') && type(jsonObj['data']) == type([])
			" Iterate over each item in the 'data' array
			for item in jsonObj['data']
				" Check if 'id' key exists in the item
				if has_key(item, 'id')
					" delete the file
					let l:curl_cmd = substitute(l:cmd,'{file_id}',item['id'],'')
					execute 'silent !' . l:curl_cmd
				endif
			endfor
		else
			echoerr "Invalid JSON structure: 'data' key not found or is not an array"
		endif
	endfunction

	" pass the json output file to the function
	let l:files = join(readfile(l:outputfile), "\n")
	call s:DeleteFilesById(l:files)
endfunction

" Command to delete all uploaded files regargedless of project.
" Note that it does not delete the assistant itself.
command! -nargs=0 OpenAIDeleteAllUploadedFiles call DeleteAllAssistantFiles()

" Function to delete all files uploaded to OpenAI for a project. See OpenAIUploadAssistantFiles for uploading files.
" Parameters:
" filepath: Path to the file containing the JSON responses
" Returns:
" None
function! DeleteCsProjectUploadedAssistantFiles(filepath)
    let l:inputfile = a:filepath
    " if filepath is empty, set it to the default
    if empty(a:filepath)
        let l:inputfile = g:OPENAI_OUTPUT_DIR . '/openai_uploaded_file_ids_output.json'
    endif

    " Read the file into a list of lines
    let lines = readfile(l:inputfile)

    " Join the lines into a single string and decode JSON
    let fileIds = json_decode(join(lines, ''))

    " Check if the decoded data is a list
    if type(fileIds) != type([])
        echoerr 'Invalid JSON: Expected a JSON array'
        return
    endif

    " Iterate over each object in the JSON array
    for fileId in fileIds
		call LogMessage('Deleting file with id: ' . fileId)
		call DeleteOpenAIAssistantFile(fileId)
    endfor
endfunction

" Command to delete all uploaded files by a project.
" Note that it does not delete the assistant itself.
command! -nargs=0 OpenAIDeleteCsProjectUploadedAssistantFiles call DeleteCsProjectUploadedAssistantFiles('')

" Function to upload all files in a directory to OpenAI
" Parameters:
" directoryPath: Path to the directory containing the files to upload
" Returns:
" List of JSON responses
function! OpenAIUploadAssistantFiles(directoryPath)
    " If directoryPath is not a directory, return
    if !isdirectory(a:directoryPath)
        call LogMessage('Directory does not exist: ' . a:directoryPath)
        return
    endif

	let l:outputfile = g:OPENAI_OUTPUT_DIR . '/openai_upload_assistant_files_output.json'
    " Define a list to store the json responses as strings
    let l:json_responses = []

    " loop through all the files in the directory
    for file in split(glob(a:directoryPath . '/*'), '\n')
        " Skip if item is an empty string (happens when glob finds nothing)
        if empty(file)
            continue
        endif
        " Check if item is a directory
        if isdirectory(file)
            " Recursively list and copy files in this directory
            call OpenAIUploadAssistantFiles(file)
        elseif filereadable(file)
            " upload the file
            let l:cmd = 'curl -sS -X POST https://api.openai.com/v1/files -H "Content-Type: multipart/form-data" -H "Authorization: Bearer ' .  $OPENAI_API_KEY . '" -F "purpose=assistants" -F "file="@' . shellescape(file, 1)

            let l:curl_cmd = l:cmd . ' -o ' . l:outputfile
            execute 'silent !' . l:curl_cmd

            " Read the content of the output file as a string
            let output = join(readfile(l:outputfile), "\n")

            " Add the response string to the list
            call add(l:json_responses, output)
        endif
    endfor

    return l:json_responses
endfunction

" Vector Store Functions

" Function to list all vector stores
" It outputs the list of vector stores to a file and returns a value indicating whether there are more vector stores to list
function! ListVectorStores(outputfile)
	let l:cmd = g:OPENAI_LIST_VECTOR_STORES_CMD
	let l:curl_cmd = l:cmd . ' -o ' . a:outputfile
	execute '!' . l:curl_cmd
	redraw!
	" Open the output file and return the value of 'hasMore' key
	let l:jsonStr = join(readfile(a:outputfile), "\n")
	let l:jsonObj = json_decode(l:jsonStr)
	if has_key(l:jsonObj, 'has_more')
		return l:jsonObj['has_more']
	endif
endfunction

function! GetVectorStoreIdsFromJson(jsonStr)
	let l:jsonObj = json_decode(a:jsonStr)
	let l:vectorStoreIds = []
	if has_key(l:jsonObj, 'data')
		for item in l:jsonObj['data']
			if has_key(item, 'id')
				call add(l:vectorStoreIds, item['id'])
			endif
		endfor
	endif
	return l:vectorStoreIds
endfunction

function! ExtractVectorStoreIdsFromJsonFile(jsonFile)
	let l:jsonStr = join(readfile(a:jsonFile), "\n")
	return GetVectorStoreIdsFromJson(l:jsonStr)
endfunction


function! DeleteAllVectorStores()
	let l:outputfile = g:OPENAI_OUTPUT_DIR . '/openai_list_vector_stores_output.json'
	let l:has_more = 1
	while l:has_more
		call ListVectorStores(l:outputfile)
		" if the output file doesn't exist, or is empty, return
		if !filereadable(l:outputfile) || getfsize(l:outputfile) == 0
			call LogMessage('No OPENAI vector stores found')
			return
		endif

		let l:vectorStoreIds = ExtractVectorStoreIdsFromJsonFile(l:outputfile)
		for vectorStoreId in l:vectorStoreIds
			call DeleteVectorStore(vectorStoreId)
		endfor
		let l:has_more = ListVectorStores(l:outputfile)
	endwhile
endfunction

function! VectorCreateJsonPayload(name, expirationDays)
	function! s:CreateExpiresAfter(anchor, days)
		return '{"anchor": "' . a:anchor . '", "days": ' . a:days . '}'
	endfunction

	return '{"name": "' . a:name . '", "expires_after": ' . s:CreateExpiresAfter('last_active_at', a:expirationDays) . '}'
endfunction

function! CreateVectorStore(name, expirationDays)
    let l:outputfile = g:OPENAI_OUTPUT_DIR . '/openai_create_vector_store_output.json'
    let l:cmd = g:OPENAI_VECTOR_STORE_CMD . json_encode(VectorCreateJsonPayload(a:name, a:expirationDays))
    let l:curl_cmd = l:cmd . ' -o ' . l:outputfile
    execute 'silent !' . l:curl_cmd

    " Maximum number of attempts to check the 'completed' status
    let l:max_attempts = 12

    " Start polling the output file
    for i in range(l:max_attempts)
        " Wait for a bit before checking the status
		call timer_start(5000, {-> v:null})

        " Read and parse the JSON output
        let l:json_output = json_decode(join(readfile(l:outputfile), "\n"))

        " Check if the status is 'completed'
        if has_key(l:json_output, 'status') && l:json_output['status'] == 'completed'
            call LogMessage("Vector store creation completed successfully. Id: " . l:json_output['id'])
			redraw!
			return l:json_output['id']
            break
        elseif has_key(l:json_output, 'status') && l:json_output['status'] == 'expired'
            echoerr "Error in creating vector store: " . l:json_output['error_message']
            break
        endif

        " Provide feedback on the status in the command line
        call LogMessage("Checking completion status... (attempt " . (i+1) . ")")
    endfor

    if i == l:max_attempts
        echoerr "Failed to verify completion after " . l:max_attempts . " attempts."
    endif
endfunction


function! GetVectorStoreToolResources(vectorStoreId, fileIds)
    " Prepare the dictionary structures
    let l:tool_resources = {
    \   'file_search': {
    \       'vector_store_ids': [a:vectorStoreId]
    \   },
    \   'code_interpreter': {
    \       'file_ids': a:fileIds
    \   }
    \}

    " Encode the complete dictionary to JSON
    let l:request = json_encode({'tool_resources': l:tool_resources})

    return l:request
endfunction

function! DeleteVectorStore(vectorStoreId)
	let l:cmd = g:OPENAI_DELETE_VECTOR_STORE_CMD
	let l:curl_cmd = substitute(l:cmd,'{vector_store_id}',a:vectorStoreId,'')
	execute '!' . l:curl_cmd
endfunction


" End Vector Store File Functions



" Uploads files and returns the file IDs.
" Parameters:
" directoryPath: Path to the directory containing the files to upload
function! UploadFiles(directoryPath)
    " Check if directoryPath is not a directory, return an empty list
    if !isdirectory(a:directoryPath)
        call LogMessage('Directory does not exist: ' . a:directoryPath)
        return []
    endif

    let l:outputfile = g:OPENAI_OUTPUT_DIR . '/openai_upload_assistant_files_output.json'
    let l:file_ids = []
    let l:json_responses = []  " This will now hold JSON strings, not objects

    " Loop through all the files in the directory
    for file in split(glob(a:directoryPath . '/*'), '\n')
        " Skip if item is an empty string (happens when glob finds nothing)
        if empty(file) || isdirectory(file)
            continue
        endif

        " Recursively process directories
        if isdirectory(file)
            let l:child_file_ids = UploadFiles(file)
            call extend(l:file_ids, l:child_file_ids)
        elseif filereadable(file)
            " Upload the file
            let l:cmd = 'curl -sS -X POST https://api.openai.com/v1/files -H "Authorization: Bearer ' . $OPENAI_API_KEY . '" -F "purpose=assistants" -F "file=@"' . shellescape(file, 1)
            let l:curl_cmd = l:cmd . ' -o ' . l:outputfile
            execute 'silent ! ' . l:curl_cmd

            " Read the output and store as a JSON string
            let output = join(readfile(l:outputfile), "\n")
            call add(l:json_responses, output)
        endif
    endfor

    redraw!

    " Use ExtractKeys to parse JSON responses and extract required keys
    if !empty(l:json_responses)
        let l:keys = ['id', 'filename']
        let l:key_values = ExtractKeys(l:json_responses, l:keys)

        " Process extracted keys here (e.g., mapping, further processing)
        " Assuming MapValues and CreateJsonWithEmptyValues are defined elsewhere
        let l:fileIdMap = MapValues(l:key_values, 'filename', 'id')
        let l:fileThreadMapping = CreateJsonWithEmptyValues(l:fileIdMap)
        call writefile(split(l:fileThreadMapping, '\n'), g:OPENAI_OUTPUT_DIR . '/openai_namespace_file_thread_mapping.json', 'b')

		" write the file ids to a file 
		call WriteJSONToFile(l:json_responses, g:OPENAI_OUTPUT_DIR . '/openai_uploaded_file_ids_output.json')
    endif
endfunction

" Define the function
function! ExtractKeys(jsonArray, keys)
    " Create a dictionary to store the results
    let resultDict = {}

    " Iterate over the array of JSON objects
    for jsonItem in a:jsonArray
        " Decode each JSON object
        let jsonObject = json_decode(jsonItem)

        " Iterate over the specified keys
        for key in a:keys
            " Check if the key exists in the JSON object
            if has_key(jsonObject, key)
                " Get the value for the key
                let value = jsonObject[key]

                " Check if the key already exists in the result dictionary
                if !has_key(resultDict, key)
                    " Initialize an empty list for this key
                    let resultDict[key] = []
                endif

                " Append the value to the list for this key
                call add(resultDict[key], value)
            endif
        endfor
    endfor

    " Return the result dictionary
    return resultDict
endfunction

function! GetIdFromJsonFile(jsonFilename)
    " Check if the file exists
    if !filereadable(a:jsonFilename)
        echoerr "File not found: " . a:jsonFilename
        return ''
    endif

    " Read the file content
    let l:fileContent = join(readfile(a:jsonFilename), "\n")

    " Decode the JSON content into a Vim data structure
    let l:jsonData = json_decode(l:fileContent)

    " Check if the 'id' property exists in the JSON data
    if has_key(l:jsonData, 'id')
        return l:jsonData['id']
    else
        echoerr "'id' property not found in the JSON file."
        return ''
    endif
endfunction


" Function to create an OpenAI assistant for a project
" Parameters:
" projectName: Name of the project
" description: Description of the project
" instructions: Instructions for the project
" Returns:
" Assistant Id
function! CreateProjectAssistant(projectName, description, instructions)
    let l:requestPayload = CreateAssistantRequestJSONPayload(a:projectName, a:description, a:instructions)
    let l:jsonEncodedPayload = json_encode(l:requestPayload)

    "
    " Properly escape the JSON payload for shell command
	" let l:escapedPayload = shellescape(l:jsonEncodedPayload, 1)

    " we need to extract the generated Assistant Id from the response
    let l:outputfile = g:OPENAI_OUTPUT_DIR . '/openai_create_project_assistant_output.json'
    let l:cmd = g:OPENAI_ASSISTANTS_CMD
	" let l:curl_cmd = l:cmd . ' -d ' . l:escapedPayload . ' -o ' . l:outputfile
    "enclose the payload in double quotes
	let l:curl_cmd = l:cmd . ' -d ' . l:jsonEncodedPayload .  ' -o ' . l:outputfile
    "echo 'curl command: ' . l:curl_cmd

    execute '!' . l:curl_cmd

    " read the output file and extract the assistant id
    return GetIdFromJsonFile(l:outputfile)
endfunction



" Generates a JSON payload for creating an OpenAI assistant
" Parameters:
" assistantName: Name of the assistant
" assistantDescription: Description of the assistant
" assistantInstructions: Instructions for the assistant
" Returns:
" JSON payload for creating an assistant
" sample call: 
	":echo CreateAssistantRequestJSONPayload("test assistant","a simple model for testing","You perform actions
" on numbers")
function! CreateAssistantRequestJSONPayload(assistantName, assistantDescription, assistantInstructions)

	let l:payload = {
		\ 'model': g:OPENAI_ASSISTANT_MODEL,
		\ 'name': a:assistantName,
		\ 'description': a:assistantDescription,
		\ 'temperature': g:OPENAI_ASSISTANT_TEMPERATURE,
		\ 'instructions': a:assistantInstructions,
		\ 'tools': [
		\   {
		\     "type": "code_interpreter"
		\   },
		\   {
		\     "type": "file_search"
		\   }
		\   ]
		\}

    return json_encode(l:payload)
endfunction

function! CreateJSONPayload(dictParam)
    return s:JSONStringify(a:dictParam)
endfunction

function! s:JSONStringify(value)
    if type(a:value) == type([])
        " Handle list
        let l:jsonList = '['
        for item in a:value
            let l:jsonList .= s:JSONStringify(item) . ','
        endfor
        let l:jsonList = substitute(l:jsonList, ',$', '', '') . ']'
        return l:jsonList
    elseif type(a:value) == type({})
        " Handle dictionary
        let l:jsonDict = '{'
        for [key, value] in items(a:value)
            let l:jsonDict .= '"' . escape(key, '"\') . '": ' . s:JSONStringify(value) . ','
        endfor
        let l:jsonDict = substitute(l:jsonDict, ',$', '', '') . '}'
        return l:jsonDict
    elseif type(a:value) == type('')
        " Handle string
        return '"' . escape(a:value, '"\') . '"'
    elseif type(a:value) == type(0) || type(a:value) == type(0.0)
        " Handle number
        return a:value
    endif
    " Add more type checks if necessary
    return ''
endfunction


"Command to group files by namespace
" Creates a dictionary with filenames as keys and namespaces as values
" Parameters:
" dir: Path to the directory containing the files from ExtractCsFiles command
" Returns:
" None
" Writes the dictionary to a JSON file named openai_group_files_by_namespace_output.json
"command! -nargs=1 GroupFilesByNamespace call GroupFilesByNamespace(<f-args>)
function! GroupFilesByNamespace(dir, ignoreFilename)
    let fileDict = {}
    let namespaceDict = {}
    let processedFiles = []
	let l:outputFile = g:OPENAI_OUTPUT_DIR . '/openai_group_files_by_namespace_output.json'

    for file in split(glob(a:dir . '/*.txt'), '\n')
        if filereadable(file) 
            let filename = fnamemodify(file, ':t:r')  " Get filename without path and extension
            if filename == fnamemodify(a:ignoreFilename, ':t:r')
                continue
            endif
            let content = readfile(file)

			for line in content
				" Match namespace declaration with optional following characters
				if line =~ '^namespace\s*\(\S\+\)\?\s*[{;]'
					if line =~ '^global using\s+\S\+;'
						break
					endif
					" Default to an anonymous namespace placeholder if no name is captured
					let namespace = matchstr(line, '^namespace\s*\(\S\+\)\?\s*[{;]')
					let namespace = substitute(namespace, '\s*[{;].*$', '', '') " Clean trailing characters
					let namespace = substitute(namespace, '^namespace\s*', '', '') " Remove the namespace keyword

					" Handle the case where no namespace name is captured (anonymous namespace)
					if namespace == ''
						let namespace = 'anonymous_namespace'
					endif

					if !has_key(fileDict, namespace)
						let fileDict[namespace] = []
					endif
					if !has_key(namespaceDict, filename)
						let namespaceDict[filename] = []
					endif
					if index(namespaceDict[filename], namespace) == -1
						call add(namespaceDict[filename], namespace . '.txt')
					endif
					call add(fileDict[namespace], content)
					call add(processedFiles, file)
					break
				endif
			endfor
		endif
    endfor

    for ns in keys(fileDict)
        call writefile(flatten(fileDict[ns]), a:dir . '/' . ns . '.txt', 'b')
    endfor

    " Encode the dictionary to a JSON string
    let jsonStr = json_encode(namespaceDict)

    " Write the JSON string to the specified output file
    call writefile(split(jsonStr, '\n'), l:outputFile, 'b')

    " Delete the processed files
    for file in processedFiles
        call delete(file)
    endfor
	call LogMessage('Files grouped by namespace')
endfunction

" Given a json file containing a dictionary with filenames as keys and namespaces as values,
" this function returns a list of namespaces for the given file,
" or an empty list if the file is not found in the dictionary
" Parameters:
" file: Path to the file containing the dictionary. filename is key sensitive without extension.
" Returns:
" List of namespaces for the given file
function! GetFileNamespaces(filesJoinNamespacesJsonFile, searchFile)
	let namespaces = []
	if filereadable(a:filesJoinNamespacesJsonFile)
		"json file containing a dictionary with filenames as keys and namespaces as values
		let jsonStr = join(readfile(a:filesJoinNamespacesJsonFile), "\n")
		let jsonObj = json_decode(jsonStr)
		" check if the dictionary has the searchFile key. If it does, return the value
		if has_key(jsonObj, a:searchFile)
			let namespaces = jsonObj[a:searchFile]
		else
			call LogMessage('File not found in the dictionary: ' . a:searchFile)
		endif
	endif
	return namespaces
endfunction


" Function to find assigned file ids for a given namespace.
" Parameters:
" filenameArray: array of filenames to search for. These are the namespaces uploaded to OpenAI from GroupFilesByNamespace command.
" jsonFilePath: [Optional] Path to the file containing the JSON response creating cs project assistant. This file contains upload assistant files output.
"Returns:
" List of file ids for the given namespace
" Sample call: echo GetUploadedFileIdByNamespace(['VirtualPaymentService.Controllers.txt'],'')
function! GetUploadedFileIdByNamespace(filenameArray, jsonFilePath)
	"if jsonFilePath is empty, set it to 'openai_upload_assistant_files_output.json'
	if empty(a:jsonFilePath)
		let l:uploadedFiles = g:OPENAI_OUTPUT_DIR . '/openai_upload_assistant_files_output.json'
	else
		let l:uploadedFiles = a:jsonFilePath
	endif
    " Read and decode the JSON file
    let jsonContent = json_decode(join(readfile(l:uploadedFiles), ''))
    
    " Initialize an empty list for matching IDs
    let matchingIds = []

    " Iterate over each object in the JSON array
    for jsonObject in jsonContent
        " Check if the 'filename' is in the given array and 'id' is present
        if has_key(jsonObject, 'filename') && has_key(jsonObject, 'id')
            if index(a:filenameArray, jsonObject['filename']) != -1
                " Add the 'id' to the list of matching IDs
                call add(matchingIds, jsonObject['id'])
            endif
        endif
    endfor

    return matchingIds
endfunction


function! GetUploadedFileIdByClassname(classname, groupFilesByNamespaceJsonFile)
	let l:uploadedFiles = g:OPENAI_OUTPUT_DIR . '/openai_uploaded_file_ids_output.json'
	" read the content of the uploaded files json and decode it to an array of strings
	let l:uploadedFilesContent = join(readfile(l:uploadedFiles), "\n")
	let l:uploadedFiles = json_decode(l:uploadedFilesContent)
	return l:uploadedFiles
endfunction

" Function to create a thread message for a given class and assign corresponding file ids from uploaded namespace files.
" It creates a new thread or uses an existing thread if one exists for the given class.
" Parameters:
" classNames: List of class names to create threads for
" Returns:
" List of thread ids
" Sample call: echo CreateThreadsByNamespace(['VirtualPaymentService.Controllers'])
" threadMessagePayload = {
"	"classname": "thrd_1GJ5Z5Z5Z5Z5Z5Z5Z5Z5Z5Z5",
"	"message": "Hello, I am a message",
" }
function! CreateAssistantThreadMessageByClassname(threadMessagePayload)
	" get the filename of the thread message payload
	let l:threadMessagePayloadFilename = fnamemodify(a:threadMessagePayload, ':t')
    " Read and decode the JSON file
    let jsonContent = json_decode(join(readfile(a:threadMessagePayload), ''))
	"get the classname from the json payload
	let l:classname = jsonContent['classname']
	"get the message from the json payload
	let l:message = jsonContent['message']
	"get array of uploaded file ids for the given classname
	let l:uploadedFileIds = GetUploadedFileIdByClassname(l:classname, '')

	function! s:ReplaceDotsInFilename(filename, replacementChar)
		" Replace all dots in the filename, except for the last one (file extension)
		let namePart = fnamemodify(a:filename, ':r')
		let extPart = fnamemodify(a:filename, ':e')

		" Replace dots in the name part
		let namePart = substitute(namePart, '\.', a:replacementChar, 'g')

		" Reconstruct the filename
		if len(extPart) > 0
			return namePart . '.' . extPart
		else
			return namePart
		endif
	endfunction


	function! s:GetNamespacesByClassname(classname, groupFilesByNamespaceJsonFile)
        " if classname is empty
        if empty(a:classname)
            let l:namespaceMappingFile = g:OPENAI_OUTPUT_DIR . '/openai_namespace_file_thread_mapping.json'
            let l:namespaces = s:GetUploadedNamespaces(l:namespaceMappingFile)
            call LogMessage('A total of ' . len(l:namespaces) . ' namespaces found in the project assistant')
			" if more than one namespace found, check if one of them is 'merged.txt'. If yes, return that namespace
			if len(l:namespaces) > 1
				let l:mergedFile = 'merged.txt'
				" check if the namespce list constains 'merged.txt'
				if index(l:namespaces, l:mergedFile) != -1
					call LogMessage('Using namespace: ' . fnamemodify(l:mergedFile, ':t'))
					return [fnamemodify(l:mergedFile, ':t')]
				endif
			endif
            return l:namespaces
        endif

		"if jsonFilePath is empty, set it to 'openai_upload_assistant_files_output.json'
		if empty(a:groupFilesByNamespaceJsonFile)
			let l:filesByNamespaceJsonFile = g:OPENAI_OUTPUT_DIR . '/openai_group_files_by_namespace_output.json'
		else
			let l:filesByNamespaceJsonFile = a:groupFilesByNamespaceJsonFile
		endif
		"Get matching namespaces for the given classname
		let l:namespaces = GetFileNamespaces(l:filesByNamespaceJsonFile, a:classname)

		" if more than one namespace found, check if one of them is 'merged.txt'. If yes, return that namespace
		if len(l:namespaces) > 1
			let l:mergedFile = 'merged.txt'
			if index(l:namespaces, l:mergedFile) != -1
				call LogMessage('Using namespace: ' . fnamemodify(l:mergedFile, ':t'))
				return [fnamemodify(l:mergedFile, ':t')]
			endif
		endif

		return l:namespaces
	endfunction

    function! s:GetUploadedNamespaces(jsonFilePath)
        " Read the JSON file into a Dictionary and return all the keys as a list
        let jsonContent = json_decode(join(readfile(a:jsonFilePath), ''))
        return keys(jsonContent)
    endfunction

	" Get array of namespaces for the given classname and create a thread for each namespace
	let l:classNamespaces = s:GetNamespacesByClassname(l:classname, '')

	" Create a thread for each namespace
	" TODO: Loop not needed here anymore. There can only be one namespace.
	for namespace in l:classNamespaces
		call LogMessage('Creating thread for namespace: ' . namespace)
		" Get a thread id for the given namespace
		"echo 'Creating thread for namespace: ' . namespace
		let l:threadId = GetThreadIdByNamespace(namespace, '')
		call LogMessage('threadId: ' . l:threadId)

		" Create a thread message payload
		let l:threadMessageRequest = ThreadMessageJsonPayload(l:threadId, l:message)

		call LogMessage('threadMessageRequest: ' . l:threadMessageRequest)
		let l:messageFilename = fnamemodify(namespace, ':t:r') . '.' . l:threadMessagePayloadFilename
		let l:threadMessageOutputFile = s:ReplaceDotsInFilename(l:messageFilename, '_')
		call LogMessage('threadMessageOutputFile: ' . l:threadMessageOutputFile)
		let l:threadMessageFile = CreateThreadMessage(l:threadMessageRequest, l:threadMessageOutputFile)
		call ExecuteThreadMessage(l:threadMessageFile, 'thread.message.completed')
	endfor
endfunction

" command to create a thread message for a given class and assign corresponding file ids from uploaded namespace files.
" It creates a new thread or uses an existing thread if one exists for the given class.
" Parameters:
" json file containing request payload. Classname is case-sensitive and without extension. Structure:
" {
"	"classname": "thrd_1GJ5Z5Z5Z5Z5Z5Z5Z5Z5Z5Z5",
"	"message": "Hello, I am a message",
" }
" Returns:
" A message object inside the 'requests' folder.
" This object should contain the thread_id, file_ids, and the message id - amonth other things.
" Sample call: :OpenAICreateMessage VirtualPaymentService.Controllers
command! -nargs=1 OpenAICreateThreadMessage call CreateAssistantThreadMessageByClassname(<f-args>)

" Creates a JSON string where each key is a filename and the value is an empty string
" returns a json string
function! CreateJsonWithEmptyValues(fileDict)
    " Initialize a new dictionary for the JSON object
    let jsonDict = {}

    " Iterate over each key-value pair in the input dictionary
    for [key, _] in items(a:fileDict)
        " Use the key (filename) with an empty string as the value
        let jsonDict[key] = ''
    endfor

    " Encode the dictionary to a JSON string
    let jsonString = json_encode(jsonDict)

    " Return the JSON string
    return jsonString
endfunction

function! GetThreadIdByNamespace(namespace, namespaceJoinThreadJsonFile)
	" if namespaceJoinThreadJsonFile is empty, set it to 'openai_namespace_join_thread_mapping.json'
	let l:namespaceThreadJsonFile = a:namespaceJoinThreadJsonFile
	if empty(a:namespaceJoinThreadJsonFile)
		let l:namespaceThreadJsonFile = g:OPENAI_OUTPUT_DIR . '/openai_namespace_file_thread_mapping.json'
	endif
    " Check if the file exists
    if !filereadable(l:namespaceThreadJsonFile)
        echoerr 'File not found: ' . l:namespaceThreadJsonFile
        return ''
    endif

    " Load the file and decode the JSON string to a dictionary
    let l:threadsJson = json_decode(join(readfile(l:namespaceThreadJsonFile), "\n"))

    " Check if the namespace is in the dictionary and its value is not null or empty
    if has_key(l:threadsJson, a:namespace) && l:threadsJson[a:namespace] != ''
        " Return the thread ID for the existing namespace
        call LogMessage('Thread ID found for namespace: ' . a:namespace)
        let l:threadId = l:threadsJson[a:namespace]
    else
        " Create a new thread for the given namespace
        let l:threadJsonString = CreateOpenAIAssistantThread()
        " Parse thread JSON string to a dictionary and get the thread ID
        let l:threadId = json_decode(l:threadJsonString)['id']
        " Add the new namespace and thread ID to the map
        let l:threadsJson[a:namespace] = l:threadId
        let l:jsonPayload = CreateJSONPayload(l:threadsJson) 
        "overwrite the file with the updated map
        call writefile(split(l:jsonPayload, '\n'), l:namespaceThreadJsonFile, 'b')
    endif

    return l:threadId
endfunction


" command to execute a thread message.
" Parameters:
" json file containing the generated thread message from "OpenAICreateMessage" command.
" returns:
" A json response inside the 'responses' directory. The file contains a collection of thread messages on the thread.
" Sample call: :OpenAIExecuteThreadMessage requests/namespace_file_thread_message.json
" command! -nargs=1 OpenAIExecuteThreadMessage call ExecuteThreadMessage(<f-args>,"")
command! -nargs=1 OpenAIExecuteThreadMessage call ExecuteThreadMessage(<f-args>,"thread.message.completed")


function! AssertNoCarriageReturns(payload)
    " Convert the dictionary to a JSON string
    let l:jsonString = json_encode(a:payload)

    " Remove any ^M characters
    let l:cleanedJsonString = substitute(l:jsonString, '\r', '', 'g')

    " Check if the lengths are the same
    if len(l:jsonString) != len(l:cleanedJsonString)
        throw 'Payload contains ^M characters'
    else
        call LogMessage('Payload does not contain ^M characters')
    endif
endfunction



function! GetThreadRunAdditionalPayload(assistantId)
    let l:additionalPayload = {
        \ "assistant_id": a:assistantId,
        \ "stream": v:true,
        \ "additional_messages": [
        \ {
            \ "role": "user",
            \ "content": "For each thread message with generated code, provide a file_path to the generated code file."
        \ }
        \ ]
    \}
    return l:additionalPayload
endfunction


" Function to execute a thread message and filter the response for a specific event name
" Parameters:
" messageJson: Path to the JSON file containing the thread message
" eventName: Name of the event to filter the response for. If the event name is empty, all events are captured.
" Returns:
" Captures all generated events to a file in the 'responses' directory - namely 'openai_thread_event_messages_output'
function! ExecuteThreadMessage(messageJson, eventName)
	let l:outputfile = g:OPENAI_RESPONSES_DIR . '/openai_thread_event_messages_output'
	" clear output file
	call writefile([], l:outputfile)  " Ensure the output file is created

	" Load project assistant and thread ID information
	let l:projectAssistantOutputFile = g:OPENAI_OUTPUT_DIR . '/openai_create_project_assistant_output.json'
	let l:projectAssistantOutput = join(readfile(l:projectAssistantOutputFile), "\n")
	let l:projectAssistantId = json_decode(l:projectAssistantOutput)['id']
	let l:threadId = json_decode(join(readfile(a:messageJson), "\n"))['thread_id']

	" Generate and encode the JSON payload
	let l:threadRunPayload = GetThreadRunAdditionalPayload(l:projectAssistantId)
	let l:threadRunJson = json_encode(l:threadRunPayload)

	" Log the JSON payload
	call LogMessage('JSON Payload: ' . l:threadRunJson)

	" Assemble the curl command for streaming as a list of arguments
	" Substitute the thread_id in the g:OPENAI_THREAD_RUN_CMD with the actual thread_id
	let l:curl_cmd = substitute(g:OPENAI_ASSISTANT_THREAD_RUN_CMD, '{thread_id}', l:threadId, '')

	" Escape the JSON payload for use in the shell command
	let l:escapedJson = shellescape(l:threadRunJson)

	" Add the thread run JSON payload to the curl command
	let l:curl_cmd = l:curl_cmd . l:escapedJson

	" Create a temporary file to store the filtered output
	let l:tempfile = tempname()
	call writefile([], l:tempfile)  " Ensure the temporary file is created

	" Verify the temporary file creation
	if !filereadable(l:tempfile)
		call LogMessage('Error: Temporary file creation failed')
		return
	endif

	" Define the shell script content for filtering the streaming response
	let l:shell_script = []
	call add(l:shell_script, '#!/bin/bash')
	call add(l:shell_script, l:curl_cmd . ' | while IFS= read -r line; do')
	call add(l:shell_script, '  if [[ "$line" =~ "event: ' . a:eventName . '" ]]; then')
	call add(l:shell_script, '    read -r line;')
	call add(l:shell_script, '    if [[ "$line" =~ "data: " ]]; then')
	call add(l:shell_script, '      response=${line#*data: }; echo $response >> ' . l:tempfile . ';')
	call add(l:shell_script, '    fi;')
	call add(l:shell_script, '  fi;')
	call add(l:shell_script, 'done')

	" Create a temporary script file
	let l:shell_script_file = tempname()
	call writefile(l:shell_script, l:shell_script_file)

	" Make the script executable
	call system('chmod +x ' . l:shell_script_file)

	" Log the shell script to verify it
	call LogMessage('Executing shell script: ' . l:shell_script_file)

	" Execute the shell script asynchronously with streaming output
	execute 'silent !' . l:shell_script_file

	" Check if the tempfile has content
	if !filereadable(l:tempfile) || getfsize(l:tempfile) == 0
		call LogMessage('Error: No data written to temporary file')
		redraw!
		return
	endif

	" Move the filtered output to the final output file
	execute 'silent !mv ' . l:tempfile . ' ' . l:outputfile

	" Verify the output file creation
	if filereadable(l:outputfile)
		call LogMessage('Curl command executed and output saved to: ' . l:outputfile)
	else
		call LogMessage('Error: Output file creation failed')
	endif

	" Clean up the temporary script file
	call delete(l:shell_script_file)

	" Extract thread message
	let l:retrievedMessageOutputFile = g:OPENAI_RESPONSES_DIR . '/openai_thread_retrieved_message_output'
	call PrintThreadRunResponse(l:retrievedMessageOutputFile)
    execute 'edit ' . l:retrievedMessageOutputFile
endfunction


" Function: ExtractThreadAndMessageIds
"
" Purpose:
"     This function reads a JSON file containing multiple JSON data objects, extracts the thread ID and message ID from
"     each object, logs the extracted IDs, and returns them as a list of dictionaries.
"
" Parameters:
"     file (string): The path to the JSON file from which the thread ID and message ID are to be extracted.
"
" Details:
"     1. Read the Entire File Content:
"         - Reads the contents of the file specified by the file parameter and joins them into a single string.
"
"     2. Split the Content by Newlines:
"         - Splits the joined content by newlines to handle multiple JSON objects.
"
"     3. Decode Each JSON Object:
"         - Decodes each JSON object from the split content into a dictionary.
"
"     4. Extract Thread ID and Message ID:
"         - Extracts the thread_id and id fields from each decoded JSON object.
"
"     5. Log the Extracted IDs:
"         - Logs the extracted thread_id and message_id using the echomsg command.
"
"     6. Return the Extracted IDs as a List of Dictionaries:
"         - Returns a list of dictionaries containing the thread_id and message_id for each JSON object.
"
" Example Usage:
"     let idsList = ExtractThreadAndMessageIds('/path/to/json/file')
"     for ids in idsList
"         echo 'Thread ID: ' . ids.thread_id
"         echo 'Message ID: ' . ids.message_id
"     endfor
"
" Notes:
"     - Ensure that the file path is correct and the file contains valid JSON with thread_id and id fields.
"
function! ExtractThreadAndMessageIds(file)
    " Read the entire file content
    let l:content = join(readfile(a:file), "\n")

    " Split the content by newlines to handle multiple JSON objects
    let l:jsonObjects = split(l:content, '\n')

    " Initialize a list to hold the extracted IDs
    let l:idsList = []

    " Iterate over each JSON object
    for jsonObject in l:jsonObjects
        " Decode the JSON content
        let l:data = json_decode(jsonObject)

        " Check if thread_id and id exist in the data
        if has_key(l:data, 'thread_id') && has_key(l:data, 'id')
            " Extract thread_id and message_id
            let l:thread_id = l:data.thread_id
            let l:message_id = l:data.id

            call LogMessage('thread_id: ' . l:thread_id)
            call LogMessage('message_id: ' . l:message_id)

            " Add the extracted IDs to the list
            call add(l:idsList, {'thread_id': l:thread_id, 'message_id': l:message_id})
        else
            call LogMessage("Error: 'thread_id' or 'id' not found in JSON data")
        endif
    endfor

    " Return the extracted IDs as a list of dictionaries
    return l:idsList
endfunction


" Function: PrintThreadRunResponse
"
" Purpose:
"     This function extracts thread and message IDs from a JSON file, retrieves messages by these IDs, formats the content,
"     combines them, and writes the formatted messages to an output file.
"
" Parameters:
"     file (string): The path to the output file where the formatted messages should be written.
"
" Details:
"     1. Extract Thread and Message IDs:
"         - Extracts thread and message IDs from the JSON file located at g:OPENAI_RESPONSES_DIR/openai_thread_event_messages_output
"         - Calls ExtractThreadAndMessageIds to get a list of dictionaries containing thread_id and message_id.
"
"     2. Clear the Output File:
"         - Clears the contents of the output file to ensure it is ready for new data.
"
"     3. Retrieve and Format Messages by ID:
"         - Iterates over the list of extracted IDs.
"         - Calls RetrieveMessageById for each thread_id and message_id, accumulating and formatting the retrieved messages.
"         - Writes the formatted messages to the output file.
"
" Example Usage:
"     call PrintThreadRunResponse('/path/to/output/file')
"         - This call extracts thread and message IDs, retrieves the corresponding messages, formats and combines them,
"           and writes them to the specified output file.
"
" Notes:
"     - Ensure that the global variable g:OPENAI_RESPONSES_DIR is properly set before calling this function.
"     - This function assumes that the ExtractThreadAndMessageIds and RetrieveMessageById functions are defined elsewhere in the codebase.
"
function! PrintThreadRunResponse(file)
    let l:sourcefile = g:OPENAI_RESPONSES_DIR . '/openai_thread_event_messages_output'
    let l:thread_message_ids = ExtractThreadAndMessageIds(l:sourcefile)

    " Clear the output file
    call writefile([], a:file)  " Ensure the output file is created

    " Initialize a list to accumulate formatted messages
    let l:formatted_messages = []

    " Retrieve and format messages by ID
    for ids in l:thread_message_ids
        " Temporarily store message content in a variable
        let l:message_tempfile = tempname()
        call RetrieveMessageById(ids.thread_id, ids.message_id, l:message_tempfile)
        let l:message_content = join(readfile(l:message_tempfile), "\n")
        call delete(l:message_tempfile) " Clean up the temporary file

        " Decode the message JSON content
        let l:message_data = json_decode(l:message_content)

        " Extract and format the content
        if has_key(l:message_data, 'content') && !empty(l:message_data.content)
            for content_item in l:message_data.content
                if has_key(content_item, 'text') && has_key(content_item.text, 'value')
                    call add(l:formatted_messages, content_item.text.value)
                endif
            endfor
        endif
    endfor

    " Write the combined and formatted messages to the output file
    call writefile(l:formatted_messages, a:file)

    redraw!
endfunction

function! RetrieveMessageById(threadId, messageId, outputFile)
	let l:curl_cmd = substitute(g:OPENAI_ASSISTANT_RETRIEVE_MESSAGE_CMD, '{message_id}', a:messageId, '')
	let l:curl_cmd = substitute(l:curl_cmd, '{thread_id}', a:threadId, '')
	let l:curl_cmd = l:curl_cmd . ' -o ' . a:outputFile

	" Log the command to verify it
	call LogMessage('Executing curl command: ' . l:curl_cmd)

	" Execute the curl command asynchronously with streaming output
	execute 'silent !' . l:curl_cmd
endfunction


" Function: CreateProjectAssistantWorkingDir
" 
" Purpose:
"     This function sets up a working directory structure for a project. It creates a main project directory and several
"     subdirectories if they do not already exist, preserving specified directories within the project directory.
" 
" Parameters:
"     projectPath (string): The path to the project's base directory.
"     projectHomeDirectory (string): The desired home directory for the project. If this parameter is empty, the function 
"                                    will create a default project directory based on the projectPath.
"     directoriesToPreserve (list): A list of directory names that should be preserved within the project directory 
"                                   when it is recreated.
"
" Details:
"     1. Determine the Output Directory:
"         - Constructs the output directory name by appending '_project' to the base name of projectPath.
"         - Defines the default home directory using the global variable g:OPENAI_WORKING_DIR.
" 
"     2. Set or Create the Project Home Directory:
"         - If projectHomeDirectory is empty:
"             - Sets projectHomeDirectory to the constructed default project directory path.
"             - Calls PreserveAndRecreate to handle the preservation of specified directories.
"         - If projectHomeDirectory is not empty:
"             - Checks if the directory exists. If not, creates it.
"             - If the directory exists, calls PreserveAndRecreate to handle the preservation of specified directories.
" 
"     3. Create Required Subdirectories:
"         - Defines subdirectories: requests, responses, output, and source.
"         - Creates these subdirectories within the projectHomeDirectory if they do not already exist.
" 
"     4. Set Global Variables:
"         - Calls ClearPersistentVariables to clear any existing global variables.
"         - Sets global variables for the project home directory and its subdirectories using SetPersistentVariable.
" 
" Example Usage:
"     call CreateProjectAssistantWorkingDir('/path/to/project', '', ['config', 'logs'])
"         - This call sets up the project working directory structure at the default location derived from 
"           '/path/to/project', preserving the 'config' and 'logs' directories.
" 
" Notes:
"     - Ensure that the global variable g:OPENAI_WORKING_DIR is properly set before calling this function.
"     - This function assumes that the PreserveAndRecreate, ClearPersistentVariables, and SetPersistentVariable functions 
"       are defined elsewhere in the codebase.
"
" Key Functions Called:
"     PreserveAndRecreate(directory, directoriesToPreserve): Preserves specified directories within the given directory and 
"                                                            recreates the directory structure.
"     ClearPersistentVariables(): Clears existing global variables related to the project.
"     SetPersistentVariable(name, value): Sets a global variable with the specified name and value.
"
function! CreateProjectAssistantWorkingDir(projectPath, projectHomeDirectory, directoriesToPreserve)
    let l:outputDir = fnamemodify(a:projectPath, ':t') .  '_project'
    let l:defaultHome = fnamemodify(g:OPENAI_WORKING_DIR, ':p')
    let l:projectDir = l:defaultHome . l:outputDir
    "if projectHomeDirectory is empty, set it to the project directory
    if empty(a:projectHomeDirectory)
        call PreserveAndRecreate(l:projectDir, a:directoriesToPreserve)
        let l:projectHomeDirectory = l:projectDir
    else
        " if directory doesn't exist, create it
        if !isdirectory(l:projectHomeDirectory)
            call mkdir(l:projectHomeDirectory, 'p')
        else
            call PreserveAndRecreate(l:projectHomeDirectory, a:directoriesToPreserve)
        endif
    endif

    " create required subdirectories
    let l:requestsDir = l:projectHomeDirectory . '/requests'
    let l:responsesDir = l:projectHomeDirectory . '/responses'
    let l:outputDir = l:projectHomeDirectory . '/output'
    let l:sourceDir = l:projectHomeDirectory . '/source'
    let l:logs = l:projectHomeDirectory . '/logs'

    if !isdirectory(l:requestsDir)
        call mkdir(l:requestsDir, 'p')
    endif
    call mkdir(l:responsesDir, 'p')
    call mkdir(l:outputDir, 'p')
    call mkdir(l:sourceDir, 'p')
    call mkdir(l:logs, 'p')

    " set global variables for the project home directory and requests and responses directories
    call ClearPersistentVariables()
    call SetPersistentVariable('OPENAI_PROJECT_HOME_DIR', l:projectHomeDirectory)
    call SetPersistentVariable('OPENAI_REQUESTS_DIR', l:requestsDir)
    call SetPersistentVariable('OPENAI_RESPONSES_DIR', l:responsesDir)
    call SetPersistentVariable('OPENAI_OUTPUT_DIR', l:outputDir)
    call SetPersistentVariable('OPENAI_SOURCE_DIR', l:sourceDir)
    call SetPersistentVariable('OPENAI_LOGS_DIR', l:logs)
endfunction


" Function: SetPersistentVariable
"
" Purpose:
"     This function sets a global variable and persists its value by saving it to a file. It ensures that the variable
"     retains its value across Vim sessions.
"
" Parameters:
"     varName (string): The name of the variable to be set.
"     varValue (string): The value to be assigned to the variable.
"
" Details:
"     1. Set the Global Variable:
"         - Assigns the given value to the global variable specified by varName.
"
"     2. Prepare the Command to be Saved:
"         - Constructs a command string to set the global variable. This command will be saved to a file for persistence.
"
"     3. Read the Current Contents of the File:
"         - Reads the current contents of the file that stores persistent variables, located at '~/.vim_persistent_variables'.
"
"     4. Add the New Command to the Contents:
"         - Appends the new command string to the contents read from the file.
"
"     5. Write the Updated Contents Back to the File:
"         - Writes the updated contents back to the file, ensuring the new variable setting is saved.
"
" Example Usage:
"     call SetPersistentVariable('MY_VARIABLE', 'my_value')
"         - This call sets the global variable 'MY_VARIABLE' to 'my_value' and persists this setting.
"
" Notes:
"     - Ensure that the file '~/.vim_persistent_variables' exists and is writable.
"     - This function assumes that the variable values do not contain single quotes, as they are used for string delimiters in the save command.
"
function! SetPersistentVariable(varName, varValue)
    " Set the global variable
    let g:{a:varName} = a:varValue

    " Prepare the command to be saved
    let saveCmd = 'let g:' . a:varName . ' = ''' . a:varValue . ''''

    " Read the current contents of the file
    let currentContents = readfile(expand('~/.vim_persistent_variables'))

    " Add the new command to the contents
    call add(currentContents, saveCmd)

    " Write the updated contents back to the file
    call writefile(currentContents, expand('~/.vim_persistent_variables'))
endfunction


function! ClearPersistentVariables()
    " Overwrite ~/.vim_persistent_variables with an empty list to clear it
    call writefile([], expand('~/.vim_persistent_variables'))
endfunction

" Function: PreserveAndRecreate
"
" Purpose:
"     This function preserves specified subdirectories within a given directory, deletes the directory, recreates it, and
"     then restores the preserved subdirectories.
"
" Parameters:
"     dir (string): The path to the directory to be recreated.
"     preserveDirs (list): A list of subdirectory names to be preserved and restored within the directory.
"
" Details:
"     1. Create a Temporary Directory:
"         - Creates a temporary directory at $HOME/temp_preserve_dir for storing the preserved subdirectories.
"
"     2. Copy Contents of PreserveDirs to TempDir:
"         - Iterates through the list of subdirectories specified in preserveDirs.
"         - If a subdirectory exists within dir, it is copied to the temporary directory.
"
"     3. Delete Contents of Dir:
"         - Deletes the entire contents of the directory specified by dir.
"
"     4. Recreate Directory and Restore Preserved Contents:
"         - Recreates the directory specified by dir.
"         - Copies the preserved subdirectories from the temporary directory back to the newly created directory.
"
"     5. Delete TempDir:
"         - Deletes the temporary directory and its contents.
"
" Example Usage:
"     call PreserveAndRecreate('/path/to/project', ['config', 'logs'])
"         - This call preserves the 'config' and 'logs' subdirectories within '/path/to/project', deletes and recreates
"           '/path/to/project', and then restores the 'config' and 'logs' subdirectories.
"
" Notes:
"     - Ensure that the temporary directory ($HOME/temp_preserve_dir) does not conflict with any existing directory.
"     - This function uses shell commands for copying and deleting directories. Ensure that the necessary permissions are
"       in place and that the shell commands are available in the environment.
"
function! PreserveAndRecreate(dir, preserveDirs)
    let tempDir = $HOME . '/temp_preserve_dir' 
    call mkdir(tempDir, 'p')

    " Step 1: Copy contents of preserveDirs to tempDir
    for preserveDir in a:preserveDirs
        let preserveDirPath = a:dir . '/' . preserveDir
        if isdirectory(preserveDirPath)
            execute 'silent !cp -r ' . shellescape(preserveDirPath) . ' ' . tempDir
        endif
    endfor

    " Step 2: Delete contents of dir
    call delete(a:dir, 'rf')

    " Step 3: Recreate directory and restore preserved contents
    call mkdir(a:dir, 'p')
    for preserveDir in a:preserveDirs
        let preserveDirPath = tempDir . '/' . preserveDir
        if isdirectory(preserveDirPath)
            execute 'silent !cp -r ' . shellescape(preserveDirPath) . ' ' . shellescape(a:dir)
        endif
    endfor

    " Step 4: Delete tempDir
    call delete(tempDir, 'rf')
endfunction

" Function: CreateLogFile
"
" Purpose:
"     Creates a log file in the 'logs' directory within the project home directory.
"     The log file name is based on the current date and time.
"
" Notes:
"     - Ensures the 'logs' directory exists before creating the log file.
"     - Logs the path of the created log file.
"
" Example Usage:
"     call CreateLogFile()
"
function! CreateLogFile()
    " Define the logs directory path
    let l:logDir = g:OPENAI_PROJECT_HOME_DIR . '/logs'

    " Create the logs directory if it doesn't exist
    if !isdirectory(l:logDir)
        call mkdir(l:logDir, 'p')
    endif

    " Define the log file name with current date and time
    let l:logFile = l:logDir . '/openai_log_' . strftime('%Y-%m-%d_%H-%M-%S') . '.log'

    " Create the log file
    call writefile([], l:logFile)

    " Log the creation of the log file
    echom 'Log file created: ' . l:logFile

    " Return the log file path
    return l:logFile
endfunction



" Function: SetupProjectAssistant
"
" Purpose:
"     This function sets up a project assistant environment by creating a working directory structure, generating a JSON
"     file with project information, and creating a sample JSON message request file.
"
" Parameters:
"     projectPath (string): The path to the project's base directory.
"     directoryToPreserve (list): A list of subdirectory names to be preserved within the project directory when it is recreated.
"
" Details:
"     1. Create a Working Directory for the Project:
"         - Calls CreateProjectAssistantWorkingDir to set up the project working directory structure and preserve specified subdirectories.
"
"     2. Create a JSON File with Project Path Information:
"         - Constructs a JSON object with the project path.
"         - Encodes the JSON object to a string.
"         - Writes the JSON string to an output file located at g:OPENAI_OUTPUT_DIR/openai_project_assistant_path_output.json.
"
"     3. Generate an Assistant Name and Create a Project Assistant:
"         - Constructs an assistant name based on the project home directory.
"         - Calls CreateOpenAICsProjectAssistant with the project path and assistant name.
"
"     4. Create a Sample JSON Message Request File:
"         - Defines a local function s:CreateSampleJsonMessageRequest to create a sample JSON message request.
"         - Writes the sample JSON message request to g:OPENAI_REQUESTS_DIR/generic_msg.json.
"         - Echoes a message indicating the creation of the sample JSON message request.
"
"     5. Complete the Setup:
"         - Echoes a completion message.
"         - Refreshes the buffer.
"         - Returns the project home directory.
"
" Example Usage:
"     call SetupProjectAssistant('/path/to/project', ['config', 'logs'])
"         - This call sets up the project assistant environment for the project located at '/path/to/project', preserving the
"           'config' and 'logs' subdirectories.
"
" Notes:
"     - Ensure that the global variables g:OPENAI_OUTPUT_DIR and g:OPENAI_REQUESTS_DIR are properly set before calling this function.
"     - This function assumes that the CreateProjectAssistantWorkingDir and CreateOpenAICsProjectAssistant functions are defined elsewhere in the codebase.
"
function! SetupProjectAssistant(projectPath, directoryToPreserve)
	" Create log file
	let s:logfile = CreateLogFile()

    " create a working directory for the project
    call CreateProjectAssistantWorkingDir(a:projectPath, '', a:directoryToPreserve)

    " create a json file with the project path and the source directory
    let l:projectAssistantJson = {"project_path": fnamemodify(a:projectPath, ':p')}
    
    " stringify the json payload
    let l:encodedProjectAssistantJson = json_encode(l:projectAssistantJson)
    
    " write the json string to output file
    let l:projectAssistantOutputFile = g:OPENAI_OUTPUT_DIR . '/openai_project_assistant_path_output.json'
    call writefile(split(l:encodedProjectAssistantJson, '\n'), l:projectAssistantOutputFile, 'b')
    
    let l:assistantName = fnamemodify(g:OPENAI_PROJECT_HOME_DIR, ':t') . '_assistant'
    let l:assistantResponse = CreateOpenAICsProjectAssistant(a:projectPath, l:assistantName)

    " local function to create a sample json message request
    function! s:CreateSampleJsonMessageRequest(dir)
        let l:sampleclassname = ''
        let l:samplemessage = 'Hello, I am a message'

        let l:sampleJsonMessageRequest = '{' . "\n" .
           \ '"classname": "' . l:sampleclassname . '",' . "\n" .
           \ '"message": "' . l:samplemessage . '"' . "\n" .
           \ '}'
        " write the json string to g:OPENAI_REQUESTS_DIR
        let l:sampleJsonMessagRequestFile = g:OPENAI_REQUESTS_DIR . '/generic_msg.json'
        call writefile(split(l:sampleJsonMessageRequest, '\n'), l:sampleJsonMessagRequestFile, 'b')
    endfunction

    " create a sample json message request
    call LogMessage("4. Starting....Created sample json message request: " . g:OPENAI_REQUESTS_DIR . '/sample_json_message_request.json')
    call s:CreateSampleJsonMessageRequest(g:OPENAI_REQUESTS_DIR)

    call LogMessage("5. Done....Setup complete.")
    " Refresh the buffer
    execute 'redraw!'
    
    return g:OPENAI_PROJECT_HOME_DIR
endfunction

" Function to merge files in a directory into a single file.
" Parameters:
" dir: The directory containing the files to merge.
" outputfile: The file to write the merged contents to.
" Returns:
" None
" Sample call: call MergeFiles('C:\Users\user\Documents\OpenAI\OpenAIAssistant\requests', 'C:\Users\user\Documents\OpenAI\OpenAIAssistant\requests\merged.txt')
function! MergeFiles(dir, outputfile)
    call LogMessage('Merging files in directory: ' . a:dir. ' into file: ' . a:outputfile)
    let l:filePaths = split(glob(a:dir . '/*'), "\n")
    call LogMessage('Files to merge: ' . join(l:filePaths, ', '))
    let l:mergedFileContents = []

    for l:file in l:filePaths
        if filereadable(l:file)
            let l:fileContents = readfile(l:file)
            let l:mergedFileContents += l:fileContents + ['']
        endif
    endfor

    call writefile(l:mergedFileContents, a:outputfile, 'b')
endfunction

" command to setup a project assistant.
" Parameters:
" projectPath: The path to the project to setup.
" returns:
" The project home directory.
command! -nargs=1 OpenAISetupProject call SetupProjectAssistant(<f-args>, [])

" Function to determine if directory paths are related.
" Parameters:
" path1: The first path to compare.
" path2: The second path to compare.
" Returns:
" 0 if the paths are not related.
" 1 if path1 is a subdirectory of path2.
" 2 if path2 is a subdirectory of path1.
function! ComparePaths(path1, path2)
    " Replace backslashes with forward slashes and remove trailing slashes
    let normalizedPath1 = substitute(a:path1, '\\', '/', 'g')
    let normalizedPath2 = substitute(a:path2, '\\', '/', 'g')

    let normalizedPath1 = substitute(normalizedPath1, '/\+$', '', '')
    let normalizedPath2 = substitute(normalizedPath2, '/\+$', '', '')

    " use stridx to check if normalizedPath1 is a substring of normalizedPath2
    if stridx(normalizedPath2, normalizedPath1) == 0
        " path2 is a subdirectory of path1
        return 2
    elseif stridx(normalizedPath1, normalizedPath2) == 0
        " path1 is a subdirectory of path2
        return 1
    else
        " path1 and path2 are not related
        return 0
    endif

endfunction

" Function to allow the user to select a project directory and set it as the working project.
" Parameters:
" projectPath: The path to the project to set as the working project.
" Returns:
" The project home directory.
function! SetWorkingProject(projectPath)
    " Check that the project setup is complete
    if !ProjectSetupComplete(a:projectPath)
        call LogMessage('Project setup is not complete. Please run :OpenAIProjectSetup')
        return ''
    endif

    let l:projectHomeDirectory = fnamemodify(a:projectPath, ':p')
	let l:defaultHome = fnamemodify(g:OPENAI_WORKING_DIR, ':p')
    let l:comparePaths = ComparePaths(l:projectHomeDirectory, l:defaultHome)

    " Make sure that l:projectHomeDirectory is inside g:OPENAI_WORKING_DIR
    " If not, return an error message
    if l:comparePaths != 1
        echoerr 'A working project directory must be inside the current working directory: ' . g:OPENAI_WORKING_DIR
        return ''
    else
        " if directory doesn't exist, create it
        if !isdirectory(l:projectHomeDirectory)
            echoerr "Project not setup. Please run :OpenAISetupProject to setup the project"
            return ''
        endif
    endif
    "
	let l:requestsDir = l:projectHomeDirectory . '/requests'
	let l:responsesDir = l:projectHomeDirectory . '/responses'
	let l:outputDir = l:projectHomeDirectory . '/output'
	let l:sourceDir = l:projectHomeDirectory . '/source'

	" set global variables for the project home directory and requests and responses directories
	call ClearPersistentVariables()
	call SetPersistentVariable('OPENAI_PROJECT_HOME_DIR', l:projectHomeDirectory)
	call SetPersistentVariable('OPENAI_REQUESTS_DIR', l:requestsDir)
	call SetPersistentVariable('OPENAI_RESPONSES_DIR', l:responsesDir)
	call SetPersistentVariable('OPENAI_OUTPUT_DIR', l:outputDir)
	call SetPersistentVariable('OPENAI_SOURCE_DIR', l:sourceDir)
    call LogMessage('Working Project set to: ' . g:OPENAI_PROJECT_HOME_DIR)
endfunction
 command! -nargs=1 OpenAISetWorkingProject call SetWorkingProject(<f-args>)


function! GetWorkingProject()
    " Check if g:OPENAI_PROJECT_HOME_DIR is defined and not empty
    if !exists('g:OPENAI_PROJECT_HOME_DIR') || empty(g:OPENAI_PROJECT_HOME_DIR)
        call LogMessage('No working project set. Please run :OpenAISetWorkingProject')
        return ''
    endif

    " Check if the directory exists
    if !isdirectory(g:OPENAI_PROJECT_HOME_DIR)
        call LogMessage('Working project directory does not exist. Please run :OpenAISetupProject')
        return ''
    endif

    " If all checks pass, echo the working project directory
    echo 'Working Project: ' . g:OPENAI_PROJECT_HOME_DIR
endfunction
command! -nargs=0 OpenAIGetWorkingProject call GetWorkingProject()

function! ProjectSetupComplete(projectPath)
    " check that the project path is a directory with the following subdirectories:
    " requests, responses, output, source
    " if any of the subdirectories is missing, return false
    " if all subdirectories exist, return true
    if !isdirectory(a:projectPath)
        return 0
    endif
    let l:projectHomeDir = fnamemodify(a:projectPath, ':p')
    let l:requestsDir = l:projectHomeDir . '/requests'
    let l:responsesDir = l:projectHomeDir . '/responses'
    let l:outputDir = l:projectHomeDir . '/output'
    let l:sourceDir = l:projectHomeDir . '/source'

    if !isdirectory(l:requestsDir) || !isdirectory(l:responsesDir) || !isdirectory(l:outputDir) || !isdirectory(l:sourceDir)
        return 0
    endif

    return 1
endfunction

command! -nargs=0 OpenAIGetHomeDirectory echo fnamemodify(g:OPENAI_WORKING_DIR, ':p')

function! SetHomeDirectory(homeDirectory)
    let l:projectHomeDir = fnamemodify(a:homeDirectory, ':p')
    " check that the home directory exists
    if !isdirectory(l:projectHomeDir)
        " create the directory
        call LogMessage('Creating directory: ' . l:projectHomeDir)
        call mkdir(l:projectHomeDir, 'p')
    endif

    let g:OPENAI_WORKING_DIR = l:projectHomeDir
    call LogMessage('Home directory set to: ' . g:OPENAI_WORKING_DIR)

    " clear project's directories
     let g:OPENAI_PROJECT_HOME_DIR = ''
     let g:OPENAI_REQUESTS_DIR = ''
     let g:OPENAI_RESPONSES_DIR = ''
     let g:OPENAI_OUTPUT_DIR = ''
     let g:OPENAI_SOURCE_DIR = ''
    "
endfunction

command! -nargs=1 OpenAISetHomeDirectory call SetHomeDirectory(<f-args>)


function! RetrieveFileById(id)
    let l:cmd = substitute(g:OPENAI_RETRIEVE_FILE_CMD, '{file_id}', a:id, 'g')
    let l:curl_cmd = l:cmd . ' | pbcopy'
    execute '!' . l:curl_cmd
endfunction

" comand to copy file content to clipboard
command! -nargs=1 OpenAIRetrieveFileContentById call RetrieveFileById(<f-args>)

function! ReloadWorkingProject()
	" reset log file
	let s:logfile = CreateLogFile()
    " get current working project
    let l:projectHomeDir = g:OPENAI_PROJECT_HOME_DIR
    " open /output/openai_create_project_assistant_output.json and parse out the id property
    let l:outputFile = l:projectHomeDir . '/output/openai_create_project_assistant_output.json'
    let l:outputJson = join(readfile(l:outputFile), "\n")
    let l:outputJsonObject = json_decode(l:outputJson)
    let l:assistantId = l:outputJsonObject['id']

    call LogMessage('Deleting project assistant: ' . l:assistantId)
    call DeleteOpenAIAssistant(l:assistantId)

    " Delete all uploaded files by the project assistant
    call DeleteCsProjectUploadedAssistantFiles('')

    " Get project to reload
    let l:projectReload = g:OPENAI_OUTPUT_DIR . '/openai_project_assistant_path_output.json'
    let l:outputJson = join(readfile(l:projectReload), "\n")
    " Parse the file and return the project_path value
    let l:projectFileObj = json_decode(l:outputJson)
    let l:projectPath = l:projectFileObj['project_path']
    let l:dirName = GetDirectoryName(l:projectPath)
    call LogMessage('Project name: ' . l:dirName)
    "Create the project assistant but retain the contents of the requests directory
    call SetupProjectAssistant(l:dirName, ['requests'])
    " Open the working project in a vertical split
    execute 'vsplit ' . l:projectHomeDir
    "
endfunction

command! -nargs=0 OpenAIReloadWorkingProject call ReloadWorkingProject()

function! GetDirectoryName(dir)
    let l:projectAssistantJson = fnamemodify(a:dir, ':p')
    let l:normalizedPath = substitute(l:projectAssistantJson, '\\', '/', 'g')
    let l:trimmedPath = substitute(l:normalizedPath, '/\+$', '', '')
    return l:trimmedPath
endfunction

if filereadable(expand("~/.vim_persistent_variables"))
	execute readfile(expand("~/.vim_persistent_variables"), 'b')->join("\n")
endif


" Function: LogMessage
"
" Purpose:
"     Logs a message to a specified log file without displaying it in the terminal.
"
" Parameters:
"     msg (string): The message to be logged.
"     logFile (string): The path to the log file where the message should be written.
"
" Example Usage:
"     call LogMessage('This is a test message', '/path/to/logfile.log')
"
function! LogMessage(msg)
    " Open the log file in append mode and write the message
	" create log file if it doesn't exist
	if !filereadable(s:logfile)
		let s:logfile = CreateLogFile()
	endif
    call writefile([a:msg], s:logfile, 'a')
endfunction


"
" Uploading a random file to Vector Store
"
function! GetActiveVectorStoreId(file)
	let l:outputJson = join(readfile(a:file), "\n")
	let l:outputJsonObject = json_decode(l:outputJson)
	let l:activeVectorStoreId = l:outputJsonObject['id']
	return l:activeVectorStoreId
endfunction

function! GetPathToVectorStoreOutputfile()
	let l:outputFile = g:OPENAI_OUTPUT_DIR . '/openai_create_vector_store_output.json'
	return l:outputFile
endfunction

" Function to upload files to the active Vector Store.
" Parameters:
" files: A list of file paths to upload to the Vector Store.
" Returns:
" None
" Sample call: call UploadFilesToVectorStore(['/path/to/file1', '/path/to/file2'])
function! UploadFilesToVectorStore(files)
	let l:fileIds = []
	let l:activeVectorStoreId = GetActiveVectorStoreId(GetPathToVectorStoreOutputfile())
	for l:file in a:files
		call LogMessage('Attempting to upload file: ' . l:file)
        if filereadable(l:file)
			let l:outputfile = tempname()
            let l:cmd = g:OPENAI_FILES_CMD . shellescape(file, 1)
            let l:curl_cmd = l:cmd . ' -o ' . l:outputfile
			call LogMessage('Uploading file: ' . l:curl_cmd)
            execute 'silent ! ' . l:curl_cmd

            " Read the output and store as a JSON string
            let output = join(readfile(l:outputfile), "\n")
			" retrieve the file id
			let l:outputJsonObject = json_decode(output)
			let l:fileId = l:outputJsonObject['id']
			call add(l:fileIds, l:fileId)
			call delete(l:outputfile)
		else
			call LogMessage('File does not exist: ' . l:file)
        endif
	endfor

	" if fileIds is empty, return
	if empty(l:fileIds)
		call LogMessage('No files uploaded to Vector Store')
		return
	endif

	let l:fileIdsToUploadToVectorStore = json_encode({"file_ids": l:fileIds}) 
	call LogMessage('File IDs to upload to Vector Store: ' . l:fileIdsToUploadToVectorStore)

	let l:vectorStoreUploadOutputFile = g:OPENAI_OUTPUT_DIR . '/openai_vector_store_additional_files_output.json'
	let l:cmd = g:OPENAI_VECTOR_STORE_FILE_CMD
	let l:response = substitute(l:cmd,'{vector_store_id}',l:activeVectorStoreId,'')
	let l:curl_cmd = l:response . shellescape(l:fileIdsToUploadToVectorStore) . ' -o ' . l:vectorStoreUploadOutputFile
	call LogMessage('curl_cmd: ' . l:curl_cmd)
	execute 'silent !' . l:curl_cmd

	" Maximum number of attempts to check the 'completed' status
	let l:max_attempts = 30

	" Start polling the output file
	for i in range(l:max_attempts)
		" Wait for a bit before checking the status
		call timer_start(5000, {-> v:null})

		" Read and parse the JSON output
		let l:json_output = json_decode(join(readfile(l:vectorStoreUploadOutputFile), "\n"))

		" Check if the status is 'completed'
		if has_key(l:json_output, 'status') && l:json_output['status'] == 'completed'
			call LogMessage("Vector store creation completed successfully. Id: " . l:json_output['id'])
			break
		elseif has_key(l:json_output, 'status') && l:json_output['status'] == 'failed'
			echoerr "Error in creating vector store: " . l:json_output['error_message']
			break
		endif

		" Provide feedback on the status in the command line
		call LogMessage("Checking completion status... (attempt " . (i+1) . ")")
	endfor
	redraw!
endfunction
